<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>OS笔记3：内存管理 | 蝈蝈影视公司</title><meta name=keywords content><meta name=description content="Desc Text."><meta name=author content="Me"><link rel=canonical href=https://canonical.url/to/page><link crossorigin=anonymous href=/MyBlog/assets/css/stylesheet.min.bd03b36c39adbc00eafcc5f0ba22ec2b9b908daa76cb014eb396e4da8a18f41b.css integrity="sha256-vQOzbDmtvADq/MXwuiLsK5uQjap2ywFOs5bk2ooY9Bs=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/MyBlog/assets/js/highlight.min.2840b7fccd34145847db71a290569594bdbdb00047097f75d6495d162f5d7dff.js integrity="sha256-KEC3/M00FFhH23GikFaVlL29sABHCX911kldFi9dff8=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://Katock-Cricket.github.io/MyBlog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://Katock-Cricket.github.io/MyBlog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://Katock-Cricket.github.io/MyBlog/favicon-32x32.png><link rel=apple-touch-icon href=https://Katock-Cricket.github.io/MyBlog/apple-touch-icon.png><link rel=mask-icon href=https://Katock-Cricket.github.io/MyBlog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="OS笔记3：内存管理"><meta property="og:description" content="Desc Text."><meta property="og:type" content="article"><meta property="og:url" content="https://Katock-Cricket.github.io/MyBlog/posts/os3/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-05-15T22:58:37+08:00"><meta property="article:modified_time" content="2022-05-15T22:58:37+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="OS笔记3：内存管理"><meta name=twitter:description content="Desc Text."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://Katock-Cricket.github.io/MyBlog/posts/"},{"@type":"ListItem","position":3,"name":"OS笔记3：内存管理","item":"https://Katock-Cricket.github.io/MyBlog/posts/os3/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"OS笔记3：内存管理","name":"OS笔记3：内存管理","description":"Desc Text.","keywords":[],"articleBody":"三、存储管理 覆盖与交换 覆盖：程序员做的，将一个大作业分割成若干小部分，当前一个部分运行结束后，其占用的内存被后面的部分直接覆盖\n交换：程序员不用做，解决运行多道程序所出现的内存不足问题，交换出暂时不需要的作业。\n分区存储 固定分区 当系统初始化时，把存储空间划分成若干个任意大小的区域；然后，把这些区域分配给每个用户作业\n 优点 ：易于实现，开销小。 缺点：内碎片造成浪费，分区总数固定，限制了并发执行的程序数目。 分配方式：单一队列与多队列  可变式分区 分区的边界可以移动，即分区的大小可变。没有内碎片，但是有外碎片。\n内碎片：分区中无法被利用的存储空间。\n外碎片：分区与分区之间的碎片，可以用紧凑技术消除外碎片。\n 空闲空间管理：位图和空闲链表 位图表示法：给每个分配单元赋予一个字位，字位取值为0表示单元闲置，取值为1则表示已被占用。 链表表示法：由“标志位(空闲或程序)+起始地址+空间长度+链表指针”构成。  分配算法 首次适应算法：从这个空白区域链的始端开始查找，选择第一个足以满足请求的空白块。\n低地址部分留下了很多很小空闲空间，增加了查找开销。\n下次适应算法：每次为存储请求查找合适的分区时，总是从上次分配的下一块开始，只要找到一个足够大的空白区，就将它划分后分配出去。\n使小空闲分区均匀分布，但会导致缺乏大空闲分区。\n最佳适应算法：总是寻找其大小最接近于作业所要求的存储区域(将空闲分区按容量递增排列)。\n留下许多小分区（碎片）。\n最坏适应算法：总是寻找最大的空白区(将空闲分区按容量递减排列)。\n当大作业来时，可能没有那么大的空间了。\n页式存储 小页面：\n  减少页内碎片和总的内存碎片，有利于提高内存利用率\n  每个进程页面数增多，使页表长度增加，占用内存较大\n  大页面：\n 每个进程页面数减少，页表长度减少，占用内存较小 增加页内碎片增大，不利于提高内存利用率  反置页表：\n依据内存中的物理页面号来组织，表项为进程pid+逻辑页号p。如果检索到与之匹配的表项，则表项的序号 i 便是该页的物理块号，将该块号与页内地址一起构成物理地址。反置页表的大小只与物理内存的大小相关，与逻辑空间大小和进程数无关。\n段式存储 每个进程一张段表，每个段一张页表。段表含页表始址和页表长度。页表含物理页号。\n缺页异常处理流程  陷入内核态，保存必要的信息（OS及用户进程状态相关的信息）。（现场保护） 查找出发生缺页中断的虚拟页面（进程地址空间中的页面）。这个虚拟页面的信息通常会保存在一个硬件寄存器中，如果没有的话，操作系统必须检索程序计数器，取出这条指令，用软件分析该指令，通过分析找出发生页面中断的虚拟页面。（页面定位） 检查虚拟地址的有效性及安全保护位。如果发生保护错误，则杀死该进程。（权限检查） 查找一个空闲的页框（物理内存中的页面），如果没有空闲页框则需要通过页面置换算法找到一个需要换出 的页框。（新页面调入（1）） 如果找的页框中的内容被修改了，则需要将修改的内容保存到磁盘上¹。（注：此时需要将页框置为忙状态，以防页框被其它进程抢占掉）（旧页面写回） 页框“干净”后，操作系统将保持在磁盘上的页面内容复制到该页框中²。（新页面调入（2）） 步骤5，6会引起写磁盘调用，发生上下文切换（在等待磁盘写的过程中让其它进程运行）。 当磁盘中的页面内容全部装入页框后，向CPU发送一个中断。操作系统更新内存中的页表项，将虚拟页面映射的页框号更新为写入的页框，并将页框标记为正常状态。（更新页表） 恢复缺页中断发生前的状态，将程序指针重新指向引起缺页中断的指令。（恢复现场） 程序重新执行引发缺页中断的指令，进行存储访问。（继续执行）  页面置换策略 Belady现象：分配的页面数增多但缺页率反而提高的异常现象\nOPT：最优置换，无法被实现，但可以用于衡量其他页面置换算法的效果。\nFIFO：先入先出，当必需置换掉某页时，选择最旧的页换出。\nSecond Chance ：每个页面都有一个标志位。用于标识此数据放入缓存队列后是否被再次访问过。删的时候如果没被访问过直接删，如果访问过的话清除标志然后跳过删下一个，这个下次再删。FIFO的改进版。\nclock：环形队列，没被访问过直接替换，被访问过的话清除标志，指向下一个。Second Chance改进版。\nLRU：每访问到一个已有的页，把它移到队尾，置换时选择队首页。\nAGING：老化算法，每个页面一个移位寄存器，每隔一段时间右移一位，访问一次就在最高位写1，置换时选数值最小的。\n页目录自映射 自映射：页表中有一项是页目录，页目录中有一项指向页目录物理地址\n对于一个4G的存储空间，有1024个4M大小的页，其中页表4M；页表有1024个4K大小的表项，其中页目录4K。给定页表基地址PTbase（4M对齐即低22位都是0）\n 页目录基地址：PDbase = PTbase | （PTbase » 10）  解析：PTbase相对于0，有 PTbase/4M 即 PTbase » 22 个页，设为xt页\n​\tPDbase相对于PTbase，有（PDbase - PTbase）/4K 即（PDbase - PTbase）« 12 个页表项，设为xd\t个页表项\n​\t因为xt = xd ，这些页和页表项一一对应。\n​\t所以联立得PDbase = PTbase + （PTbase » 10）\n自映射目录项：PDEself-mapping = PTbase | （PTbase » 10）| （PTbase » 20）  解析：PTbase相对于0，有 PTbase/4M 即 PTbase » 22 个页，设为xt页\n​\tPDbase相对于PTbase，有（PDbase - PTbase）/4K 即（PDbase - PTbase）« 12 个页表项，设为xd\t个页表项\n​\tPDEself相对于PDbase，有（PDEself - PDbase）/4 即（PDEself - PDbase）« 2 个页目录项，设为\txe个页目录项\n​\t因为xt = xd =xe，这些页、页表项和页目录项一一对应；\n​\t所以联立消PDbase得 PDEself-mapping = PTbase + （PTbase » 10）+ （PTbase » 20）\nELF文件 .bss\t此节存放用于程序内存映象的未初始化数据。此节类型是SHT_NOBITS,因此不占文件空间。\n.data和.datal\t此节存放用于程序内存映象的初始化数据。\n.text\t此节存放正文，也称程序的执行指令。\n伙伴系统 略\n纯分页内存管理 基本分页管理，没有页面置换，一次性为程序分配所需物理内存。支持多级页表但不是动态装入。\n反置页表 用物理页号找逻辑页号和进程号，有多少物理页框就有多少页表项；是为了减小页表占用空间。\n抖动 驻留内存的进程数目增加，即进程并发程度的提高，处理器利用率先上升，然后下降。即将过多的CPU资源用来换页而不是进程。\n原因：并发进程数量过多、物理内存不足、缺页率快速上升\n 测试题 计算机从内存RAM向缓存Cache传输数据的单位 Cache line\n构成高速缓存Cache的基本存储器件是 SRAM\n采用固定分区进行内存分配，容易产生 内碎片\n某次内存分配后，剩余3块空闲空间，大小分别为1k、10k、100k。这时按顺序来了一批4k、6k、95k的作业内存需求，哪种算法能够满足尽量多的作业： Best fit 正确\nWorst fit 错误\n内存紧缩中用的重定位技术与程序链接过程中的重定位 前者是运行时的动态重定位，程序所占用的内存实际发生了变化（为了消除碎片高效利用内存），程序中的地址要随之发生变化，典型的应用是java虚拟机；\n后者是编译链接过程中的重定位，主要原因是编译时程序地址在内存中的地址不确定，当多个程序编译链接后计算出程序地址的操作。\n页式内存管理缺点 内碎片、访问页表存在延迟、页表占用空间\n页面大小是8KB，虚拟地址0x13345所表示的页内偏移是 0x1345，8K=1«13，取地址低13位\n页表项中记录有哪些信息 页框号、标志位\n当TLB未命中时，后续会执行哪些处理 MMU访问页表获得页框号，根据页表项更新TLB\n假设虚拟地址有64位，页面大小为4KB，一个页表项占8个字节，如果采用一级页表，页表需要占用多少内存 地址空间2^64^B，一页2^12^B，一共2^52^页，一个表项2^3^B，则共2^55^B\n关于多级页表 能够减少页表占用内存的大小、有效的页表项中都会存储页框号、使用二级页表的平均访存性能优于一级页表，但是平均访问时间不会减少\n在采用按需调页的系统中，影响内存读写平均延迟的因素有 外存读写速度、TLB命中率、进程切换开销、换页算法\n一个32位页式内存管理系统，页面大小是4KB，采用二级页表管理，页表被映射到起始地址0xC000_0000的4MB地址空间，如果需要将虚拟地址0x8001_0000映射到物理地址0x0000_0000上，则需要修改虚拟地址0x____________________上的页表项 每4KB一页，则0x8001_0000所在的页是0x8001_0000 / 4K = 0x80010，第0x80010个页。\n每个页占用4B的页表项，则该页所在页表项在页表中的偏移是0x80010 * 4B = 0x200040，\n页表起始地址为0xc000_0000，则该页表项的地址为 0xc000_0000 + 0x200040 = 0xc020_0040。\n一个32位的虚拟存储系统有两级页表，其逻辑地址中，第22到31位是第一级页表（页目录）的索引，第12位到21位是第二级页表的索引，页内偏移占第0到11位。每个页表（目录）项包含20位物理页框号和12位标志位，其中最后1位为页有效位。\n1 32位地址，对应2^32^B即4GB存储空间；页偏移量12位，对应2^12^B即4KB的页大小\n2  0x0，页目录号0，查表得0000号页目录项的内容是0x0，其中页面有效位为0，缺页 0x00803004，转二进制0000 0000 1000 0000 0011 0000 0000 0100，得页目录号0000 0000 10等于2，查表得0002号页目录项的内容是0x5001，转二进制0101 0000 0000 0001取高20位得到物理页框号5，页是4K对齐所以物理地址是0x5000，根据虚拟地址的二级页表号00 0000 0011等于3，查表页表第三项内容0x2 0001（有效），得物理页框号0x20，同理得物理地址0x2 0000，根据虚拟地址得页内偏移量4，从0x9000开始往后数4个字即8个十六进制位得到0x0032 6001，大段读0，小段读1。 0x0040_2001 = 0b0000_0000_0100_0000_0010_0000_0000_0001，得页目录号00_0000_0001等于1，查表得物理地址0x1000，由虚拟地址二级页表项为2，查表得页面物理地址0x5000，由虚拟地址偏移量为1，查表得0 要访问0x326028，首先得虚拟地址的页内偏移0x028=0000 0010 1000，它的页框基地址为0x326000，查表得在0x2 0000的第0001处，所以虚拟地址的二级页表号为1=00 0000 0001，然后查页目录得第0003号是0x2 0001，得页目录号3=00 0000 0011，合起来得虚拟地址0000 0000 1100 0000 0001 0000 0010 1000=0x00c0 1028  ","wordCount":"265","inLanguage":"en","datePublished":"2022-05-15T22:58:37+08:00","dateModified":"2022-05-15T22:58:37+08:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://Katock-Cricket.github.io/MyBlog/posts/os3/"},"publisher":{"@type":"Organization","name":"蝈蝈影视公司","logo":{"@type":"ImageObject","url":"https://Katock-Cricket.github.io/MyBlog/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://Katock-Cricket.github.io/MyBlog accesskey=h title="蝈蝈影视公司 (Alt + H)">蝈蝈影视公司</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://Katock-Cricket.github.io/MyBlog>Home</a>&nbsp;»&nbsp;<a href=https://Katock-Cricket.github.io/MyBlog/posts/>Posts</a></div><h1 class=post-title>OS笔记3：内存管理</h1><div class=post-description>Desc Text.</div><div class=post-meta><span title="2022-05-15 22:58:37 +0800 +0800">May 15, 2022</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/Katock-Cricket/MyBlog/content/posts/OS3.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e4%b8%89%e5%ad%98%e5%82%a8%e7%ae%a1%e7%90%86 aria-label=三、存储管理>三、存储管理</a><ul><ul><li><a href=#%e8%a6%86%e7%9b%96%e4%b8%8e%e4%ba%a4%e6%8d%a2 aria-label=覆盖与交换>覆盖与交换</a></li><li><a href=#%e5%88%86%e5%8c%ba%e5%ad%98%e5%82%a8 aria-label=分区存储>分区存储</a><ul><li><a href=#%e5%9b%ba%e5%ae%9a%e5%88%86%e5%8c%ba aria-label=固定分区>固定分区</a></li><li><a href=#%e5%8f%af%e5%8f%98%e5%bc%8f%e5%88%86%e5%8c%ba aria-label=可变式分区>可变式分区</a></li></ul></li><li><a href=#%e5%88%86%e9%85%8d%e7%ae%97%e6%b3%95 aria-label=分配算法>分配算法</a></li><li><a href=#%e9%a1%b5%e5%bc%8f%e5%ad%98%e5%82%a8 aria-label=页式存储>页式存储</a></li><li><a href=#%e6%ae%b5%e5%bc%8f%e5%ad%98%e5%82%a8 aria-label=段式存储>段式存储</a></li><li><a href=#%e7%bc%ba%e9%a1%b5%e5%bc%82%e5%b8%b8%e5%a4%84%e7%90%86%e6%b5%81%e7%a8%8b aria-label=缺页异常处理流程>缺页异常处理流程</a></li><li><a href=#%e9%a1%b5%e9%9d%a2%e7%bd%ae%e6%8d%a2%e7%ad%96%e7%95%a5 aria-label=页面置换策略>页面置换策略</a></li><li><a href=#%e9%a1%b5%e7%9b%ae%e5%bd%95%e8%87%aa%e6%98%a0%e5%b0%84 aria-label=页目录自映射>页目录自映射</a></li><li><a href=#elf%e6%96%87%e4%bb%b6 aria-label=ELF文件>ELF文件</a></li><li><a href=#%e4%bc%99%e4%bc%b4%e7%b3%bb%e7%bb%9f aria-label=伙伴系统>伙伴系统</a></li><li><a href=#%e7%ba%af%e5%88%86%e9%a1%b5%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86 aria-label=纯分页内存管理>纯分页内存管理</a></li><li><a href=#%e5%8f%8d%e7%bd%ae%e9%a1%b5%e8%a1%a8 aria-label=反置页表>反置页表</a></li><li><a href=#%e6%8a%96%e5%8a%a8 aria-label=抖动>抖动</a></li><li><a href=#%e6%b5%8b%e8%af%95%e9%a2%98 aria-label=测试题>测试题</a><ul><ul><li><a href=#%e8%ae%a1%e7%ae%97%e6%9c%ba%e4%bb%8e%e5%86%85%e5%ad%98ram%e5%90%91%e7%bc%93%e5%ad%98cache%e4%bc%a0%e8%be%93%e6%95%b0%e6%8d%ae%e7%9a%84%e5%8d%95%e4%bd%8d aria-label=计算机从内存RAM向缓存Cache传输数据的单位>计算机从内存RAM向缓存Cache传输数据的单位</a></li><li><a href=#%e6%9e%84%e6%88%90%e9%ab%98%e9%80%9f%e7%bc%93%e5%ad%98cache%e7%9a%84%e5%9f%ba%e6%9c%ac%e5%ad%98%e5%82%a8%e5%99%a8%e4%bb%b6%e6%98%af aria-label=构成高速缓存Cache的基本存储器件是>构成高速缓存Cache的基本存储器件是</a></li><li><a href=#%e9%87%87%e7%94%a8%e5%9b%ba%e5%ae%9a%e5%88%86%e5%8c%ba%e8%bf%9b%e8%a1%8c%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e5%ae%b9%e6%98%93%e4%ba%a7%e7%94%9f aria-label=采用固定分区进行内存分配，容易产生>采用固定分区进行内存分配，容易产生</a></li><li><a href=#%e6%9f%90%e6%ac%a1%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e5%90%8e%e5%89%a9%e4%bd%993%e5%9d%97%e7%a9%ba%e9%97%b2%e7%a9%ba%e9%97%b4%e5%a4%a7%e5%b0%8f%e5%88%86%e5%88%ab%e4%b8%ba1k10k100k%e8%bf%99%e6%97%b6%e6%8c%89%e9%a1%ba%e5%ba%8f%e6%9d%a5%e4%ba%86%e4%b8%80%e6%89%b94k6k95k%e7%9a%84%e4%bd%9c%e4%b8%9a%e5%86%85%e5%ad%98%e9%9c%80%e6%b1%82%e5%93%aa%e7%a7%8d%e7%ae%97%e6%b3%95%e8%83%bd%e5%a4%9f%e6%bb%a1%e8%b6%b3%e5%b0%bd%e9%87%8f%e5%a4%9a%e7%9a%84%e4%bd%9c%e4%b8%9a aria-label=某次内存分配后，剩余3块空闲空间，大小分别为1k、10k、100k。这时按顺序来了一批4k、6k、95k的作业内存需求，哪种算法能够满足尽量多的作业：>某次内存分配后，剩余3块空闲空间，大小分别为1k、10k、100k。这时按顺序来了一批4k、6k、95k的作业内存需求，哪种算法能够满足尽量多的作业：</a></li><li><a href=#%e5%86%85%e5%ad%98%e7%b4%a7%e7%bc%a9%e4%b8%ad%e7%94%a8%e7%9a%84%e9%87%8d%e5%ae%9a%e4%bd%8d%e6%8a%80%e6%9c%af%e4%b8%8e%e7%a8%8b%e5%ba%8f%e9%93%be%e6%8e%a5%e8%bf%87%e7%a8%8b%e4%b8%ad%e7%9a%84%e9%87%8d%e5%ae%9a%e4%bd%8d aria-label=内存紧缩中用的重定位技术与程序链接过程中的重定位>内存紧缩中用的重定位技术与程序链接过程中的重定位</a></li><li><a href=#%e9%a1%b5%e5%bc%8f%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86%e7%bc%ba%e7%82%b9 aria-label=页式内存管理缺点>页式内存管理缺点</a></li><li><a href=#%e9%a1%b5%e9%9d%a2%e5%a4%a7%e5%b0%8f%e6%98%af8kb%e8%99%9a%e6%8b%9f%e5%9c%b0%e5%9d%800x13345%e6%89%80%e8%a1%a8%e7%a4%ba%e7%9a%84%e9%a1%b5%e5%86%85%e5%81%8f%e7%a7%bb%e6%98%af aria-label=页面大小是8KB，虚拟地址0x13345所表示的页内偏移是>页面大小是8KB，虚拟地址0x13345所表示的页内偏移是</a></li><li><a href=#%e9%a1%b5%e8%a1%a8%e9%a1%b9%e4%b8%ad%e8%ae%b0%e5%bd%95%e6%9c%89%e5%93%aa%e4%ba%9b%e4%bf%a1%e6%81%af aria-label=页表项中记录有哪些信息>页表项中记录有哪些信息</a></li><li><a href=#%e5%bd%93tlb%e6%9c%aa%e5%91%bd%e4%b8%ad%e6%97%b6%e5%90%8e%e7%bb%ad%e4%bc%9a%e6%89%a7%e8%a1%8c%e5%93%aa%e4%ba%9b%e5%a4%84%e7%90%86 aria-label=当TLB未命中时，后续会执行哪些处理>当TLB未命中时，后续会执行哪些处理</a></li><li><a href=#%e5%81%87%e8%ae%be%e8%99%9a%e6%8b%9f%e5%9c%b0%e5%9d%80%e6%9c%8964%e4%bd%8d%e9%a1%b5%e9%9d%a2%e5%a4%a7%e5%b0%8f%e4%b8%ba4kb%e4%b8%80%e4%b8%aa%e9%a1%b5%e8%a1%a8%e9%a1%b9%e5%8d%a08%e4%b8%aa%e5%ad%97%e8%8a%82%e5%a6%82%e6%9e%9c%e9%87%87%e7%94%a8%e4%b8%80%e7%ba%a7%e9%a1%b5%e8%a1%a8%e9%a1%b5%e8%a1%a8%e9%9c%80%e8%a6%81%e5%8d%a0%e7%94%a8%e5%a4%9a%e5%b0%91%e5%86%85%e5%ad%98 aria-label=假设虚拟地址有64位，页面大小为4KB，一个页表项占8个字节，如果采用一级页表，页表需要占用多少内存>假设虚拟地址有64位，页面大小为4KB，一个页表项占8个字节，如果采用一级页表，页表需要占用多少内存</a></li><li><a href=#%e5%85%b3%e4%ba%8e%e5%a4%9a%e7%ba%a7%e9%a1%b5%e8%a1%a8 aria-label=关于多级页表>关于多级页表</a></li><li><a href=#%e5%9c%a8%e9%87%87%e7%94%a8%e6%8c%89%e9%9c%80%e8%b0%83%e9%a1%b5%e7%9a%84%e7%b3%bb%e7%bb%9f%e4%b8%ad%e5%bd%b1%e5%93%8d%e5%86%85%e5%ad%98%e8%af%bb%e5%86%99%e5%b9%b3%e5%9d%87%e5%bb%b6%e8%bf%9f%e7%9a%84%e5%9b%a0%e7%b4%a0%e6%9c%89 aria-label=在采用按需调页的系统中，影响内存读写平均延迟的因素有>在采用按需调页的系统中，影响内存读写平均延迟的因素有</a></li><li><a href=#%e4%b8%80%e4%b8%aa32%e4%bd%8d%e9%a1%b5%e5%bc%8f%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86%e7%b3%bb%e7%bb%9f%e9%a1%b5%e9%9d%a2%e5%a4%a7%e5%b0%8f%e6%98%af4kb%e9%87%87%e7%94%a8%e4%ba%8c%e7%ba%a7%e9%a1%b5%e8%a1%a8%e7%ae%a1%e7%90%86%e9%a1%b5%e8%a1%a8%e8%a2%ab%e6%98%a0%e5%b0%84%e5%88%b0%e8%b5%b7%e5%a7%8b%e5%9c%b0%e5%9d%800xc000_0000%e7%9a%844mb%e5%9c%b0%e5%9d%80%e7%a9%ba%e9%97%b4%e5%a6%82%e6%9e%9c%e9%9c%80%e8%a6%81%e5%b0%86%e8%99%9a%e6%8b%9f%e5%9c%b0%e5%9d%800x8001_0000%e6%98%a0%e5%b0%84%e5%88%b0%e7%89%a9%e7%90%86%e5%9c%b0%e5%9d%800x0000_0000%e4%b8%8a%e5%88%99%e9%9c%80%e8%a6%81%e4%bf%ae%e6%94%b9%e8%99%9a%e6%8b%9f%e5%9c%b0%e5%9d%800x____________________%e4%b8%8a%e7%9a%84%e9%a1%b5%e8%a1%a8%e9%a1%b9 aria-label=一个32位页式内存管理系统，页面大小是4KB，采用二级页表管理，页表被映射到起始地址0xC000_0000的4MB地址空间，如果需要将虚拟地址0x8001_0000映射到物理地址0x0000_0000上，则需要修改虚拟地址0x____________________上的页表项>一个32位页式内存管理系统，页面大小是4KB，采用二级页表管理，页表被映射到起始地址0xC000_0000的4MB地址空间，如果需要将虚拟地址0x8001_0000映射到物理地址0x0000_0000上，则需要修改虚拟地址0x____________________上的页表项</a><ul><li><a href=#1 aria-label=1>1</a></li><li><a href=#2 aria-label=2>2</a></li></ul></ul></li></ul></ul></li></ul></li></ul></div></details></div><div class=post-content><h1 id=三存储管理>三、存储管理<a hidden class=anchor aria-hidden=true href=#三存储管理>#</a></h1><h3 id=覆盖与交换>覆盖与交换<a hidden class=anchor aria-hidden=true href=#覆盖与交换>#</a></h3><p>覆盖：程序员做的，将一个大作业分割成若干小部分，当前一个部分运行结束后，其占用的内存被后面的部分直接覆盖</p><p>交换：程序员不用做，解决运行多道程序所出现的内存不足问题，交换出暂时不需要的作业。</p><h3 id=分区存储>分区存储<a hidden class=anchor aria-hidden=true href=#分区存储>#</a></h3><h4 id=固定分区>固定分区<a hidden class=anchor aria-hidden=true href=#固定分区>#</a></h4><p>当系统初始化时，把存储空间划分成若干个任意大小的区域；然后，把这些区域分配给每个用户作业</p><ul><li>优点 ：易于实现，开销小。</li><li>缺点：内碎片造成浪费，分区总数固定，限制了并发执行的程序数目。</li><li>分配方式：单一队列与多队列</li></ul><h4 id=可变式分区>可变式分区<a hidden class=anchor aria-hidden=true href=#可变式分区>#</a></h4><p>分区的边界可以移动，即分区的大小可变。没有内碎片，但是有外碎片。</p><p>内碎片：分区中无法被利用的存储空间。</p><p>外碎片：分区与分区之间的碎片，可以用紧凑技术消除外碎片。</p><ul><li>空闲空间管理：位图和空闲链表</li><li>位图表示法：给每个分配单元赋予一个字位，字位取值为0表示单元闲置，取值为1则表示已被占用。</li><li>链表表示法：由“标志位(空闲或程序)+起始地址+空间长度+链表指针”构成。</li></ul><p><img loading=lazy src=1.png alt=1.png></p><h3 id=分配算法>分配算法<a hidden class=anchor aria-hidden=true href=#分配算法>#</a></h3><p><strong>首次适应算法</strong>：从这个空白区域链的始端开始查找，选择第一个足以满足请求的空白块。</p><p>低地址部分留下了很多很小空闲空间，增加了查找开销。</p><p><strong>下次适应算法</strong>：每次为存储请求查找合适的分区时，总是从上次分配的下一块开始，只要找到一个足够大的空白区，就将它划分后分配出去。</p><p>使小空闲分区均匀分布，但会导致缺乏大空闲分区。</p><p><strong>最佳适应算法</strong>：总是寻找其大小最接近于作业所要求的存储区域(将空闲分区按容量递增排列)。</p><p>留下许多小分区（碎片）。</p><p><strong>最坏适应算法</strong>：总是寻找最大的空白区(将空闲分区按容量递减排列)。</p><p>当大作业来时，可能没有那么大的空间了。</p><h3 id=页式存储>页式存储<a hidden class=anchor aria-hidden=true href=#页式存储>#</a></h3><p>小页面：</p><ol><li><p>减少页内碎片和总的内存碎片，有利于提高内存利用率</p></li><li><p>每个进程页面数增多，使页表长度增加，占用内存较大</p></li></ol><p>大页面：</p><ol><li>每个进程页面数减少，页表长度减少，占用内存较小</li><li>增加页内碎片增大，不利于提高内存利用率</li></ol><p>反置页表：</p><p>依据内存中的物理页面号来组织，表项为进程pid+逻辑页号p。如果检索到与之匹配的表项，则表项的序号 i 便是该页的物理块号，将该块号与页内地址一起构成物理地址。反置页表的大小只与物理内存的大小相关，与逻辑空间大小和进程数无关。</p><h3 id=段式存储>段式存储<a hidden class=anchor aria-hidden=true href=#段式存储>#</a></h3><p>每个进程一张段表，每个段一张页表。段表含页表始址和页表长度。页表含物理页号。</p><p><img loading=lazy src=2.png alt=2.png></p><h3 id=缺页异常处理流程>缺页异常处理流程<a hidden class=anchor aria-hidden=true href=#缺页异常处理流程>#</a></h3><ol><li>陷入内核态，保存必要的信息（OS及用户进程状态相关的信息）。（现场保护）</li><li>查找出发生缺页中断的虚拟页面（进程地址空间中的页面）。这个虚拟页面的信息通常会保存在一个硬件寄存器中，如果没有的话，操作系统必须检索程序计数器，取出这条指令，用软件分析该指令，通过分析找出发生页面中断的虚拟页面。（页面定位）</li><li>检查虚拟地址的有效性及安全保护位。如果发生保护错误，则杀死该进程。（权限检查）</li><li>查找一个空闲的页框（物理内存中的页面），如果没有空闲页框则需要通过页面置换算法找到一个需要换出
的页框。（新页面调入（1））</li><li>如果找的页框中的内容被修改了，则需要将修改的内容保存到磁盘上¹。（注：此时需要将页框置为忙状态，以防页框被其它进程抢占掉）（旧页面写回）</li><li>页框“干净”后，操作系统将保持在磁盘上的页面内容复制到该页框中²。（新页面调入（2））</li><li>步骤5，6会引起写磁盘调用，发生上下文切换（在等待磁盘写的过程中让其它进程运行）。</li><li>当磁盘中的页面内容全部装入页框后，向CPU发送一个中断。操作系统更新内存中的页表项，将虚拟页面映射的页框号更新为写入的页框，并将页框标记为正常状态。（更新页表）</li><li>恢复缺页中断发生前的状态，将程序指针重新指向引起缺页中断的指令。（恢复现场）</li><li>程序重新执行引发缺页中断的指令，进行存储访问。（继续执行）</li></ol><h3 id=页面置换策略>页面置换策略<a hidden class=anchor aria-hidden=true href=#页面置换策略>#</a></h3><p>Belady现象：分配的页面数增多但缺页率反而提高的异常现象</p><p><strong>OPT</strong>：最优置换，无法被实现，但可以用于衡量其他页面置换算法的效果。</p><p><strong>FIFO</strong>：先入先出，当必需置换掉某页时，选择最旧的页换出。</p><p><strong>Second Chance</strong> ：每个页面都有一个标志位。用于标识此数据放入缓存队列后是否被再次访问过。删的时候如果没被访问过直接删，如果访问过的话清除标志然后跳过删下一个，这个下次再删。FIFO的改进版。</p><p><strong>clock</strong>：环形队列，没被访问过直接替换，被访问过的话清除标志，指向下一个。Second Chance改进版。</p><p><img loading=lazy src=3.png alt=3.png></p><p><strong>LRU</strong>：每访问到一个已有的页，把它移到队尾，置换时选择队首页。</p><p><strong>AGING</strong>：老化算法，每个页面一个移位寄存器，每隔一段时间右移一位，访问一次就在最高位写1，置换时选数值最小的。</p><h3 id=页目录自映射>页目录自映射<a hidden class=anchor aria-hidden=true href=#页目录自映射>#</a></h3><p>自映射：页表中有一项是页目录，页目录中有一项指向页目录物理地址</p><p>对于一个4G的存储空间，有1024个4M大小的页，其中页表4M；页表有1024个4K大小的表项，其中页目录4K。给定页表基地址PTbase（4M对齐即低22位都是0）</p><ol><li>页目录基地址：<strong>PDbase = PTbase | （PTbase &#187; 10）</strong></li></ol><p>解析：PTbase相对于0，有 PTbase/4M 即 PTbase &#187; 22 个页，设为<code>xt</code>页</p><p>​ PDbase相对于PTbase，有（PDbase - PTbase）/4K 即（PDbase - PTbase）&#171; 12 个页表项，设为<code>xd</code> 个页表项</p><p>​ 因为<code>xt</code> = <code>xd</code> ，这些页和页表项一一对应。</p><p>​ 所以联立得PDbase = PTbase + （PTbase &#187; 10）</p><ol start=2><li>自映射目录项：<strong>PDEself-mapping = PTbase | （PTbase &#187; 10）| （PTbase &#187; 20）</strong></li></ol><p>解析：PTbase相对于0，有 PTbase/4M 即 PTbase &#187; 22 个页，设为<code>xt</code>页</p><p>​ PDbase相对于PTbase，有（PDbase - PTbase）/4K 即（PDbase - PTbase）&#171; 12 个页表项，设为<code>xd</code> 个页表项</p><p>​ PDEself相对于PDbase，有（PDEself - PDbase）/4 即（PDEself - PDbase）&#171; 2 个页目录项，设为 <code>xe</code>个页目录项</p><p>​ 因为<code>xt</code> = <code>xd</code> =<code>xe</code>，这些页、页表项和页目录项一一对应；</p><p>​ 所以联立消PDbase得 PDEself-mapping = PTbase + （PTbase &#187; 10）+ （PTbase &#187; 20）</p><h3 id=elf文件>ELF文件<a hidden class=anchor aria-hidden=true href=#elf文件>#</a></h3><p><img loading=lazy src=4.png alt=4.png></p><p>.bss 此节存放用于程序内存映象的未初始化数据。此节类型是SHT_NOBITS,因此不占文件空间。</p><p>.data和.datal 此节存放用于程序内存映象的初始化数据。</p><p>.text 此节存放正文，也称程序的执行指令。</p><h3 id=伙伴系统>伙伴系统<a hidden class=anchor aria-hidden=true href=#伙伴系统>#</a></h3><p>略</p><h3 id=纯分页内存管理>纯分页内存管理<a hidden class=anchor aria-hidden=true href=#纯分页内存管理>#</a></h3><p>基本分页管理，没有页面置换，一次性为程序分配所需物理内存。支持多级页表但不是动态装入。</p><h3 id=反置页表>反置页表<a hidden class=anchor aria-hidden=true href=#反置页表>#</a></h3><p>用物理页号找逻辑页号和进程号，有多少物理页框就有多少页表项；是为了减小页表占用空间。</p><h3 id=抖动>抖动<a hidden class=anchor aria-hidden=true href=#抖动>#</a></h3><p>驻留内存的进程数目增加，即进程并发程度的提高，处理器利用率先上升，然后下降。即将过多的CPU资源用来换页而不是进程。</p><p>原因：并发进程数量过多、物理内存不足、缺页率快速上升</p><hr><h3 id=测试题>测试题<a hidden class=anchor aria-hidden=true href=#测试题>#</a></h3><h5 id=计算机从内存ram向缓存cache传输数据的单位>计算机从内存RAM向缓存Cache传输数据的单位<a hidden class=anchor aria-hidden=true href=#计算机从内存ram向缓存cache传输数据的单位>#</a></h5><p>Cache line</p><h5 id=构成高速缓存cache的基本存储器件是>构成高速缓存Cache的基本存储器件是<a hidden class=anchor aria-hidden=true href=#构成高速缓存cache的基本存储器件是>#</a></h5><p>SRAM</p><h5 id=采用固定分区进行内存分配容易产生>采用固定分区进行内存分配，容易产生<a hidden class=anchor aria-hidden=true href=#采用固定分区进行内存分配容易产生>#</a></h5><p>内碎片</p><h5 id=某次内存分配后剩余3块空闲空间大小分别为1k10k100k这时按顺序来了一批4k6k95k的作业内存需求哪种算法能够满足尽量多的作业>某次内存分配后，剩余3块空闲空间，大小分别为1k、10k、100k。这时按顺序来了一批4k、6k、95k的作业内存需求，哪种算法能够满足尽量多的作业：<a hidden class=anchor aria-hidden=true href=#某次内存分配后剩余3块空闲空间大小分别为1k10k100k这时按顺序来了一批4k6k95k的作业内存需求哪种算法能够满足尽量多的作业>#</a></h5><p>Best fit 正确</p><p>Worst fit 错误</p><h5 id=内存紧缩中用的重定位技术与程序链接过程中的重定位>内存紧缩中用的重定位技术与程序链接过程中的重定位<a hidden class=anchor aria-hidden=true href=#内存紧缩中用的重定位技术与程序链接过程中的重定位>#</a></h5><p>前者是运行时的动态重定位，程序所占用的内存实际发生了变化（为了消除碎片高效利用内存），程序中的地址要随之发生变化，典型的应用是java虚拟机；</p><p>后者是编译链接过程中的重定位，主要原因是编译时程序地址在内存中的地址不确定，当多个程序编译链接后计算出程序地址的操作。</p><h5 id=页式内存管理缺点>页式内存管理缺点<a hidden class=anchor aria-hidden=true href=#页式内存管理缺点>#</a></h5><p>内碎片、访问页表存在延迟、页表占用空间</p><h5 id=页面大小是8kb虚拟地址0x13345所表示的页内偏移是>页面大小是8KB，虚拟地址0x13345所表示的页内偏移是<a hidden class=anchor aria-hidden=true href=#页面大小是8kb虚拟地址0x13345所表示的页内偏移是>#</a></h5><p>0x1345，8K=1&#171;13，取地址低13位</p><h5 id=页表项中记录有哪些信息>页表项中记录有哪些信息<a hidden class=anchor aria-hidden=true href=#页表项中记录有哪些信息>#</a></h5><p>页框号、标志位</p><h5 id=当tlb未命中时后续会执行哪些处理>当TLB未命中时，后续会执行哪些处理<a hidden class=anchor aria-hidden=true href=#当tlb未命中时后续会执行哪些处理>#</a></h5><p>MMU访问页表获得页框号，根据页表项更新TLB</p><h5 id=假设虚拟地址有64位页面大小为4kb一个页表项占8个字节如果采用一级页表页表需要占用多少内存>假设虚拟地址有64位，页面大小为4KB，一个页表项占8个字节，如果采用一级页表，页表需要占用多少内存<a hidden class=anchor aria-hidden=true href=#假设虚拟地址有64位页面大小为4kb一个页表项占8个字节如果采用一级页表页表需要占用多少内存>#</a></h5><p>地址空间2^64^B，一页2^12^B，一共2^52^页，一个表项2^3^B，则共2^55^B</p><h5 id=关于多级页表>关于多级页表<a hidden class=anchor aria-hidden=true href=#关于多级页表>#</a></h5><p>能够减少页表占用内存的大小、有效的页表项中都会存储页框号、使用二级页表的平均访存性能优于一级页表，但是平均访问时间不会减少</p><h5 id=在采用按需调页的系统中影响内存读写平均延迟的因素有>在采用按需调页的系统中，影响内存读写平均延迟的因素有<a hidden class=anchor aria-hidden=true href=#在采用按需调页的系统中影响内存读写平均延迟的因素有>#</a></h5><p>外存读写速度、TLB命中率、进程切换开销、换页算法</p><h5 id=一个32位页式内存管理系统页面大小是4kb采用二级页表管理页表被映射到起始地址0xc000_0000的4mb地址空间如果需要将虚拟地址0x8001_0000映射到物理地址0x0000_0000上则需要修改虚拟地址0x____________________上的页表项>一个32位页式内存管理系统，页面大小是4KB，采用二级页表管理，页表被映射到起始地址0xC000_0000的4MB地址空间，如果需要将虚拟地址0x8001_0000映射到物理地址0x0000_0000上，则需要修改虚拟地址0x____________________上的页表项<a hidden class=anchor aria-hidden=true href=#一个32位页式内存管理系统页面大小是4kb采用二级页表管理页表被映射到起始地址0xc000_0000的4mb地址空间如果需要将虚拟地址0x8001_0000映射到物理地址0x0000_0000上则需要修改虚拟地址0x____________________上的页表项>#</a></h5><p>每4KB一页，则0x8001_0000所在的页是0x8001_0000 / 4K = 0x80010，第0x80010个页。</p><p>每个页占用4B的页表项，则该页所在页表项在页表中的偏移是0x80010 * 4B = 0x200040，</p><p>页表起始地址为0xc000_0000，则该页表项的地址为 0xc000_0000 + 0x200040 = 0xc020_0040。</p><p><strong>一个32位的虚拟存储系统有两级页表，其逻辑地址中，第22到31位是第一级页表（页目录）的索引，第12位到21位是第二级页表的索引，页内偏移占第0到11位。每个页表（目录）项包含20位物理页框号和12位标志位，其中最后1位为页有效位。</strong></p><p><img loading=lazy src=5.png alt></p><p><img loading=lazy src=6.png alt></p><h6 id=1>1<a hidden class=anchor aria-hidden=true href=#1>#</a></h6><p>32位地址，对应2^32^B即4GB存储空间；页偏移量12位，对应2^12^B即4KB的页大小</p><h6 id=2>2<a hidden class=anchor aria-hidden=true href=#2>#</a></h6><ol><li>0x0，页目录号0，查表得0000号页目录项的内容是0x0，其中页面有效位为0，缺页</li><li>0x00803004，转二进制0000 0000 1000 0000 0011 0000 0000 0100，得页目录号0000 0000 10等于2，查表得0002号页目录项的内容是0x5001，转二进制0101 0000 0000 0001取高20位得到物理页框号5，页是4K对齐所以物理地址是0x5000，根据虚拟地址的二级页表号00 0000 0011等于3，查表页表第三项内容0x2 0001（有效），得物理页框号0x20，同理得物理地址0x2 0000，根据虚拟地址得页内偏移量4，从0x9000开始往后数4个字即8个十六进制位得到0x0032 6001，大段读0，小段读1。</li><li>0x0040_2001 = 0b0000_0000_0100_0000_0010_0000_0000_0001，得页目录号00_0000_0001等于1，查表得物理地址0x1000，由虚拟地址二级页表项为2，查表得页面物理地址0x5000，由虚拟地址偏移量为1，查表得0</li><li>要访问0x326028，首先得虚拟地址的页内偏移0x028=0000 0010 1000，它的页框基地址为0x326000，查表得在0x2 0000的第0001处，所以虚拟地址的二级页表号为1=00 0000 0001，然后查页目录得第0003号是0x2 0001，得页目录号3=00 0000 0011，合起来得虚拟地址0000 0000 1100 0000 0001 0000 0010 1000=0x00c0 1028</li></ol></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://Katock-Cricket.github.io/MyBlog/posts/os4/><span class=title>« Prev Page</span><br><span>OS笔记4：进程与并发程序设计</span></a>
<a class=next href=https://Katock-Cricket.github.io/MyBlog/posts/os2/><span class=title>Next Page »</span><br><span>OS笔记2：系统引导</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://Katock-Cricket.github.io/MyBlog>蝈蝈影视公司</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>