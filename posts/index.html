<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | 蝈蝈影视公司</title><meta name=keywords content><meta name=description content="Posts - 蝈蝈影视公司"><meta name=author content><link rel=canonical href=https://Katock-Cricket.github.io/MyBlog/posts/><link crossorigin=anonymous href=/MyBlog/assets/css/stylesheet.min.bd03b36c39adbc00eafcc5f0ba22ec2b9b908daa76cb014eb396e4da8a18f41b.css integrity="sha256-vQOzbDmtvADq/MXwuiLsK5uQjap2ywFOs5bk2ooY9Bs=" rel="preload stylesheet" as=style><link rel=icon href=https://Katock-Cricket.github.io/MyBlog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://Katock-Cricket.github.io/MyBlog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://Katock-Cricket.github.io/MyBlog/favicon-32x32.png><link rel=apple-touch-icon href=https://Katock-Cricket.github.io/MyBlog/apple-touch-icon.png><link rel=mask-icon href=https://Katock-Cricket.github.io/MyBlog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://Katock-Cricket.github.io/MyBlog/posts/index.xml><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Posts"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://Katock-Cricket.github.io/MyBlog/posts/"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://Katock-Cricket.github.io/MyBlog/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://Katock-Cricket.github.io/MyBlog accesskey=h title="蝈蝈影视公司 (Alt + H)">蝈蝈影视公司</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu></ul></nav></header><main class=main><header class=page-header><h1>Posts</h1></header><article class=post-entry><div class=post-info><header class=entry-header><h2>OS笔记4：进程与并发程序设计</h2></header><div class=entry-content><p>四、进程与并发程序设计 并发与并行 并发：两个活动在同一时间各自处在起点和终点之间的某一处，不一定并行（不一定都在处理机上）
并行：两个程序在同一时间度量下同时运行在不同的处理机上
进程与程序 进程：数据+程序+PCB（进程管理块）
通过多次执行，一个程序对应多个进程；通过调用，一个进程包括多个程序
进程原语 指令序列执行是连续的，不可分割 是操作系统核心组成部分 必须在管态（内核态）下执行，且常驻内存 进程三状态 就绪、执行、等待
进程与线程 资源拥有者称为进程，可执行单元称为线程。将资源与计算分离，提高并发效率；
线程作用：减小进程切换的开销；提高进程内的并发程度；共享资源
一个进程可以拥有多个线程，而一个线程同时只能被一个进程所拥有 进程是资源分配的基本单位，线程是处理机调度的基本单位，所有的线程共享其所属进程的所有资源与代码 线程共享进程的数据的同时，线程有自己私有的的堆栈 进程通信 临界资源：一次仅允许一个进程访问的资源
临界区：每个进程中访问临界资源的那段代码
同步：直接制约，逻辑上的依赖
互斥：间接制约，资源的等待
同步互斥原则：
空闲让进：临界资源处于空闲状态，允许进程进入临界区 忙则等待：临界区有正在执行的进程，所有其他进程则不可以进入临界区 有限等待：对要求访问临界区的进程，应在保证在有限时间内进入自己的临界区，避免死等 让权等待：当进程（长时间）不能进入自己的临界区时，应立即释放处理机，尽量避免忙等 信号量：PV操作
管程：分散的临界区集中起来，为每个可共享资源设计一个专门机构来统一管理各进程对该资源的访问，管程是一种语言概念，由编译器负责实现互斥，任一时刻，管程中只能有一个活跃进程。
调度算法 短作业优先 先来先服务 最短剩余时间SRTF 最高相应比优先HRRF 时间片轮转算法 优先级算法 死锁 死锁、活锁、饥饿
死锁发生的必要条件：互斥、请求和占有、不可剥夺、环路等待
安全序列：序列中每个进程需要的附加资源 &lt;= 当前可用资源 + 它前面所有进程占有的资源
银行家算法：先看request（当前进程请求资源量）是否小于need（当前进程可能需要的最大资源量-当前占有量），小于的话再看request是否小于available（当前还有多少可用），如果都行的话假设分配一下用安全性算法检测，若安全则分配否则不分配
安全性算法：找need&lt;work的进程，有的话，这个进程对应的finish数组置true，work+=allocate，初始时work=available，如果最后所有进程全为true则安全
RAG资源分配图算法……</p></div><footer class=entry-footer><span title="2022-05-15 22:58:42 +0800 +0800">May 15, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to OS笔记4：进程与并发程序设计" href=https://Katock-Cricket.github.io/MyBlog/posts/os4/></a></div></article><article class=post-entry><div class=post-info><header class=entry-header><h2>OS笔记3：内存管理</h2></header><div class=entry-content><p>三、存储管理 覆盖与交换 覆盖：程序员做的，将一个大作业分割成若干小部分，当前一个部分运行结束后，其占用的内存被后面的部分直接覆盖
交换：程序员不用做，解决运行多道程序所出现的内存不足问题，交换出暂时不需要的作业。
分区存储 固定分区 当系统初始化时，把存储空间划分成若干个任意大小的区域；然后，把这些区域分配给每个用户作业
优点 ：易于实现，开销小。 缺点：内碎片造成浪费，分区总数固定，限制了并发执行的程序数目。 分配方式：单一队列与多队列 可变式分区 分区的边界可以移动，即分区的大小可变。没有内碎片，但是有外碎片。
内碎片：分区中无法被利用的存储空间。
外碎片：分区与分区之间的碎片，可以用紧凑技术消除外碎片。
空闲空间管理：位图和空闲链表 位图表示法：给每个分配单元赋予一个字位，字位取值为0表示单元闲置，取值为1则表示已被占用。 链表表示法：由“标志位(空闲或程序)+起始地址+空间长度+链表指针”构成。 分配算法 首次适应算法：从这个空白区域链的始端开始查找，选择第一个足以满足请求的空白块。
低地址部分留下了很多很小空闲空间，增加了查找开销。
下次适应算法：每次为存储请求查找合适的分区时，总是从上次分配的下一块开始，只要找到一个足够大的空白区，就将它划分后分配出去。
使小空闲分区均匀分布，但会导致缺乏大空闲分区。
最佳适应算法：总是寻找其大小最接近于作业所要求的存储区域(将空闲分区按容量递增排列)。
留下许多小分区（碎片）。
最坏适应算法：总是寻找最大的空白区(将空闲分区按容量递减排列)。
当大作业来时，可能没有那么大的空间了。
页式存储 小页面：
减少页内碎片和总的内存碎片，有利于提高内存利用率
每个进程页面数增多，使页表长度增加，占用内存较大
大页面：
每个进程页面数减少，页表长度减少，占用内存较小 增加页内碎片增大，不利于提高内存利用率 反置页表：
依据内存中的物理页面号来组织，表项为进程pid+逻辑页号p。如果检索到与之匹配的表项，则表项的序号 i 便是该页的物理块号，将该块号与页内地址一起构成物理地址。反置页表的大小只与物理内存的大小相关，与逻辑空间大小和进程数无关。
段式存储 每个进程一张段表，每个段一张页表。段表含页表始址和页表长度。页表含物理页号。
缺页异常处理流程 陷入内核态，保存必要的信息（OS及用户进程状态相关的信息）。（现场保护） 查找出发生缺页中断的虚拟页面（进程地址空间中的页面）。这个虚拟页面的信息通常会保存在一个硬件寄存器中，如果没有的话，操作系统必须检索程序计数器，取出这条指令，用软件分析该指令，通过分析找出发生页面中断的虚拟页面。（页面定位） 检查虚拟地址的有效性及安全保护位。如果发生保护错误，则杀死该进程。（权限检查） 查找一个空闲的页框（物理内存中的页面），如果没有空闲页框则需要通过页面置换算法找到一个需要换出 的页框。（新页面调入（1）） 如果找的页框中的内容被修改了，则需要将修改的内容保存到磁盘上¹。（注：此时需要将页框置为忙状态，以防页框被其它进程抢占掉）（旧页面写回） 页框“干净”后，操作系统将保持在磁盘上的页面内容复制到该页框中²。（新页面调入（2）） 步骤5，6会引起写磁盘调用，发生上下文切换（在等待磁盘写的过程中让其它进程运行）。 当磁盘中的页面内容全部装入页框后，向CPU发送一个中断。操作系统更新内存中的页表项，将虚拟页面映射的页框号更新为写入的页框，并将页框标记为正常状态。（更新页表） 恢复缺页中断发生前的状态，将程序指针重新指向引起缺页中断的指令。（恢复现场） 程序重新执行引发缺页中断的指令，进行存储访问。（继续执行） 页面置换策略 Belady现象：分配的页面数增多但缺页率反而提高的异常现象
OPT：最优置换，无法被实现，但可以用于衡量其他页面置换算法的效果。
FIFO：先入先出，当必需置换掉某页时，选择最旧的页换出。...</p></div><footer class=entry-footer><span title="2022-05-15 22:58:37 +0800 +0800">May 15, 2022</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to OS笔记3：内存管理" href=https://Katock-Cricket.github.io/MyBlog/posts/os3/></a></div></article><article class=post-entry><div class=post-info><header class=entry-header><h2>OS笔记2：系统引导</h2></header><div class=entry-content><p>二、系统引导 MIPS启动流程 两个阶段：Stage1（汇编代码），Stage2（C代码）
四个虚拟空间：kseg0（最高位置0得物理地址，cache存取），kseg1（高三位置0，不用cache，重启时可正常工作），kseg2（内核态，MMU转换），kuseg（用户态，MMU转换）
Stage1 Stage2 MIPS下Linux启动流程 Bootloader将 Linux 内核映像拷贝到RAM 从head.s文件的kernel_entry()开始，初始化内核堆栈 …… ELF文件 测试题 Bootloader的实现严重依赖于具体硬件，即使是相同的CPU，它的外设(比如Flash)也可能不同，所以不可能有一个Bootloader支持所有的CPU、所有的开发板。但是bootloader是可以支持不同CPU架构和不同操作系统，只不过常常不能直接拿来用，需要做一些移植的工作。
MIPS平台外设IO空间通常映射到kseg1段，映射到0xA0000000-0xBFFFFFFF的不通过cache的空间中。
cc1是预处理器和编译器，as是汇编器，collect2是链接器，他们都是gcc所包含的工具。
C语言要支持不定个数的参数，其压栈顺序就必然是从右至左。
C程序真正的入口点是_start，它首先做一些初始化工作（启动例程， Startup Routine），然后调用C代码中提供的main函数。
Linux中sys_execve()只是函数do_execve()的一个界面，实际的处理加载可执行文件动作在do_execve()中完成。</p></div><footer class=entry-footer><span title="2022-05-15 22:58:33 +0800 +0800">May 15, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to OS笔记2：系统引导" href=https://Katock-Cricket.github.io/MyBlog/posts/os2/></a></div></article><article class=post-entry><div class=post-info><header class=entry-header><h2>OS笔记1：操作系统概论</h2></header><div class=entry-content><p>一、操作系统概论 批处理 把用户提交的作业成批送入计算机，由作业调度程序自动选择作业运行。
作用：
缩短作业之间的交接时间
减少处理机的空闲等待，提高系统效率
多道程序 指允许多个程序同时进入内存并运行。即同时把多个程序放入内存中，并允许它们交替在CPU中运行
好处：
提高CPU利用率； 提高I/O设备和内存利用率； 进而提高系统效率 分时 多个用户分享使用同一台计算机。多个程序分时共享硬件和软件资源。
分布式操作系统 网络操作系统：在传统单机OS上加单独软件层，主要提供联网功能和资源的远程访问，实现多机互联。
分布式操作系统：多台机器统一管理形成单一系统，相比网络操作系统，对用户和应用高度透明(看不到也不需要看到)
实时系统：及时响应，高可靠性和安全性，系统的整体性强，交互会话活动较弱，专用系统
操作系统主要功能 进程管理，存储器管理，设备管理，文件系统，作业控制
现代操作系统的基本特征 并发执行，资源共享(复用)，虚拟化管理，不确定性事件的处理
操作系统工作模式 内核态(管态)，用户态(目态)；
切换过程：通过异常(陷阱或中断)，进入内核态
异常与中断 中断：主要由I/O设备、处理器时钟或定时器等硬件产生，可以被启用或禁用
陷阱：用户进程中某一特定指令执行的结果，
在相同条件下，异常可以重现，例如内存访问错误、调试指令以及被零除。
系统调用 提供操作系统服务的编程接口
与函数调用的区别：
用户态到内核态，切换堆栈 移植性差 开销较大 过程：先跳转到异常分发代码，通过异常类型调用handle_sys函数根据系统调用号完成系统调用的实现
操作系统内核 是一个操作系统的核心。它负责管理系统的进程、内存、设备驱动程序、文件和网络系统，决定着系统的性能和稳定性。通过异常来陷入内核态。
微内核 内核只完成不得不完成的功能，其他诸如文件系统、内存管理、设备驱动等的内容都被作为系统进程放到了用户态空间。
好处：架构独立，减小系统耦合，增加可移植性。
坏处：频繁系统调用，效率难以保证。
测试题 分时系统与批处理系统相比，主要的开销是什么？ 管理时间片的系统开销、管理多用户的系统开销、管理硬件的系统开销（引入了虚存）、交互IO的系统开销等等。</p></div><footer class=entry-footer><span title="2022-05-15 22:58:26 +0800 +0800">May 15, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to OS笔记1：操作系统概论" href=https://Katock-Cricket.github.io/MyBlog/posts/os1/></a></div></article><article class=post-entry><div class=post-info><header class=entry-header><h2>上班摸鱼</h2></header><div class=entry-content><p>平平无奇のGenshin Impact截图</p></div><footer class=entry-footer><span title="2022-05-09 22:43:59 +0800 +0800">May 9, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 上班摸鱼" href=https://Katock-Cricket.github.io/MyBlog/posts/pictures_test/></a></div><figure class=entry-cover><img loading=lazy src=https://pic4.zhimg.com/v2-2596e3516f4eabb4b261f45f029fbed3_r.jpg alt></figure></article><article class=post-entry><div class=post-info><header class=entry-header><h2>吃饱喝饱一路走好</h2></header><div class=entry-content><p>蝈总的老婆</p></div><footer class=entry-footer><span title="2022-05-09 00:00:00 +0000 UTC">May 9, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 吃饱喝饱一路走好" href=https://Katock-Cricket.github.io/MyBlog/posts/my-first-post/></a></div><figure class=entry-cover><img loading=lazy src=https://img2.huashi6.com/images/resource/thumbnail/2021/10/28/18222_3429341215.jpg?imageMogr2/quality/75/interlace/1/thumbnail/1400x/gravity/North/crop/1400x2100/format/webp alt></figure></article></main><footer class=footer><span>&copy; 2022 <a href=https://Katock-Cricket.github.io/MyBlog>蝈蝈影视公司</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>